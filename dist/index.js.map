{"version":3,"sources":["index.js"],"names":["client","config","process","env","STAGE","connect","Client","disconnect","end","query","text","values","transaction","commands","command","e","generateId","charsCount","CHARS","digits","i","bytes","crypto","randomBytes","pseudoRandomBytes","hexString","toString","substring","fraction","parseInt","index","Math","floor","length","substr","join"],"mappings":";;;;;;;;;AAAA;;AACA;;AAEA,IAAIA,MAAJ;AACA,MAAMC,SAASC,QAAQC,GAAR,CAAYC,KAAZ,KAAsB,OAAtB,GACb;AACA,IAFa,GAGX,CACA;AADA,CAHJ;AAOA;;;;;;;;AAOA,MAAMC,UAAU,YAAY;AAC1B,MAAI,CAACL,MAAL,EAAa;AACXA,aAAS,IAAIM,UAAJ,CAAWL,MAAX,CAAT,CADW,CAEX;;AACA,UAAMD,OAAOK,OAAP,EAAN;AACD;AACF,CAND;AAQA;;;;;;;;;;AAMA,MAAME,aAAa,YAAY;AAC7B,MAAIP,MAAJ,EAAY;AACV,UAAMA,OAAOQ,GAAP,EAAN;AACAR,aAAS,IAAT;AACD;AACF,CALD;AAOA;;;;;;;;;;;;;AASA,MAAMS,QAAQ,OAAOC,IAAP,EAAaC,MAAb,KAAwB;AACpC,MAAI,CAACX,MAAL,EAAa;AACX,UAAMK,SAAN;AACD;;AACD,SAAOL,OAAOS,KAAP,CAAaC,IAAb,EAAmBC,MAAnB,CAAP;AACD,CALD;AAOA;;;;;;;;;;;;;AASA,MAAMC,cAAc,OAAOC,WAAW,EAAlB,KAAyB;AAC3C,MAAI,CAACb,MAAL,EAAa;AACX,UAAMK,SAAN;AACD;;AACD,MAAI;AACF,UAAML,OAAOS,KAAP,CAAa,OAAb,CAAN;;AACA,SAAI,IAAIK,OAAR,IAAmBD,QAAnB,EAA4B;AAC1B,YAAMb,OAAOS,KAAP,CAAaK,OAAb,CAAN;AACD;;AACD,UAAMd,OAAOS,KAAP,CAAa,QAAb,CAAN;AACD,GAND,CAME,OAAMM,CAAN,EAAS;AACT,UAAMf,OAAOS,KAAP,CAAa,UAAb,CAAN;AACA,UAAMM,CAAN;AACD;;AACD,SAAOf,OAAOS,KAAP,CAAaC,IAAb,EAAmBC,MAAnB,CAAP;AACD,CAfD;AAiBA;;;;;;;;;;;AAOA,MAAMK,aAAa,CAACC,aAAa,EAAd,KAAqB;AACtC,QAAMC,QAAQ,yDAAd;AACA,QAAMC,SAAS,EAAf;;AACA,OAAK,IAAIC,IAAI,CAAb,EAAgBA,IAAIH,UAApB,EAAgCG,GAAhC,EAAqC;AACnC,QAAIC,KAAJ;;AACA,QAAI;AACFA,cAAQC,gBAAOC,WAAP,CAAmB,CAAnB,CAAR;AACD,KAFD,CAEE,OAAOR,CAAP,EAAU;AACVM,cAAQC,gBAAOE,iBAAP,CAAyB,CAAzB,CAAR;AACD;;AACD,UAAMC,YAAYJ,MAAMK,QAAN,CAAe,KAAf,EAAsBC,SAAtB,CAAgC,CAAhC,EAAmC,CAAnC,CAAlB;AACA,UAAMC,WAAWC,SAASJ,SAAT,EAAoB,EAApB,IAA0B,sBAA3C;AACA,UAAMK,QAAQC,KAAKC,KAAL,CAAWJ,WAAWV,MAAMe,MAA5B,CAAd;AACAd,WAAOC,CAAP,IAAYF,MAAMgB,MAAN,CAAaJ,KAAb,EAAoB,CAApB,CAAZ;AACD;;AACD,SAAOX,OAAOgB,IAAP,CAAY,EAAZ,CAAP;AACD,CAhBD","sourcesContent":["import { Client } from \"pg\";\nimport crypto from \"crypto\";\n\nlet client;\nconst config = process.env.STAGE === \"local\" ? \n  // local connection handled entirely via env vars\n  null \n  : {\n    // TODO: CloudSQL Proxy Connection\n  };\n\n/**\n * Connects to database using info defined in environment variables \n * (MONGO_URL, MONGO_DATABASE, MONGO_SSL, MONGO_SSL_VALIDATE).\n *\n * @async\n * @function connect\n */\nconst connect = async () => {\n  if (!client) {\n    client = new Client(config);\n    // Connect to Postgres server.\n    await client.connect();\n  }\n};\n\n/**\n * Disconnects from database.\n *\n * @async\n * @function disconnect\n */\nconst disconnect = async () => {\n  if (client) {\n    await client.end();\n    client = null;\n  }\n};\n\n/**\n * Runs a query.\n *\n * @function query\n * @param {String} text the SQL you want to run\n * @param {Array} values the array of values you want \n *  to inject into the query\n * @return {Db} MongoDB instance of the Db class.\n */\nconst query = async (text, values) => {\n  if (!client) {\n    await connect();\n  }\n  return client.query(text, values);\n};\n\n/**\n * Runs a set of queries as a transaction.\n * See: https://node-postgres.com/features/transactions\n *\n * @function transaction\n * @param {Array[{text: String, values: [String/Number/etc]}]} commands the set of SQL commands you want to run\n *  It's an array of objects who each have a `text` string and a `values` array.\n * @return {Db} MongoDB instance of the Db class.\n */\nconst transaction = async (commands = []) => {\n  if (!client) {\n    await connect();\n  }\n  try {\n    await client.query('BEGIN')\n    for(let command of commands){\n      await client.query(command);\n    }\n    await client.query('COMMIT');\n  } catch(e) {\n    await client.query('ROLLBACK')\n    throw e;\n  }\n  return client.query(text, values);\n};\n\n/**\n * Generates ID string.\n *\n * @function generateId\n * @param {number} charsCount - Length of the ID string.\n * @return {string} randomized ID string.\n */\nconst generateId = (charsCount = 17) => {\n  const CHARS = \"23456789ABCDEFGHJKLMNPQRSTWXYZabcdefghijkmnopqrstuvwxyz\";\n  const digits = [];\n  for (let i = 0; i < charsCount; i++) {\n    let bytes;\n    try {\n      bytes = crypto.randomBytes(4);\n    } catch (e) {\n      bytes = crypto.pseudoRandomBytes(4);\n    }\n    const hexString = bytes.toString(\"hex\").substring(0, 8);\n    const fraction = parseInt(hexString, 16) * 2.3283064365386963e-10;\n    const index = Math.floor(fraction * CHARS.length);\n    digits[i] = CHARS.substr(index, 1);\n  }\n  return digits.join(\"\");\n};\n\nexport { connect, disconnect, query, transaction };"]}